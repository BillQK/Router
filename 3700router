#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, copy, re

#another test
class ForwardingTables: 
    def __init__(self):
        self.entries = []
        self.testrouting = {}

        #networks/netmasks, then the ips for it, for routing stuff
        #{172.169, 172.168.0.2}
        #{12, 192.169.0.2, 10.0.0.2}

        #{192, 192.168}
        #{172, 172.169}
        #{12, 12.0.0.25}

        #update
        #172.168.0.2, connected to router(peer), updated
        #add this in like a list {172, 172.168.0.2, 172.169.0.1}
        #when someone sends a message
        #we want to a send some data to this ip
        #172.169.0.25 network thats being transmitted
        #if theres two examples of the entworks
        #compare and then send data to 172.169.0.1(closer to what its asking for?)

        #10.0.0.2
        #{10, 10.0.02}
        #one of the networks being send data is
        #11.0.0.25
        #port that don't know

        #192.168.1.25
        #two networks -> 12.0.0.25, and connected 192.168.
        #{12.0.0}

        #{network, and the subsequent fields: ips with it}

    # Add entries 
    def add_entries(self, srcif, msg): 
        self.entries.append(msg)

    def printData(self):
        for e in self.entries.values(): 
            print(e)

    def addToRouting(self, msg):
        peer = msg["src"]
        lpref = msg['msg']['localpref']
        selforigin = msg['msg']['selfOrigin']
        aspath = msg['msg']['ASPath']
        #origin
        #src with the lowest ip address

        routeinfo = [peer, lpref, selforigin, aspath]

        #have a port field in there as well

        network = msg["msg"]["network"]
        netmask = msg['msg']['netmask']

        prefixednetwork = self.determinenetwork(network, netmask)
        self.testrouting.setdefault(prefixednetwork, [])
        self.testrouting[prefixednetwork].append(routeinfo)
        #print("this is what is being added to the list " + str(self.testrouting[prefixednetwork]))

       #subnet mask/bitwise operations, and get the network ip 
    def determinenetwork(self, network, netmask):
        test = []
        pattern = re.compile(r'255')
        matches = pattern.findall(netmask)
        network = network.split(".")

        for i in range(len(matches)):
            test.append(network[i])

        test = '.'.join(test)

        return test

    def convertToBinary(self, msg):
        prefix = msg["network"]
        netmask = msg["netmask"]
        
        #converting to eventually check withe netmask(count the ones)
        #with the number that has the correct amount depending on the netmask
        #then thats the address that we send things to?

        separatedecimal = prefix.split(".")
        print(separatedecimal)
        nlist = []
        testlist = []

        for i in separatedecimal:
            nlist.append(bin(int(i)).replace("0b", ""))

        for i in nlist:
            testlist.append(i.zfill(8))

        str = '.'.join(testlist)
        num = self.countOnes(str)  

        print(str)    
        #index = countOnes(bnetmask)
        #for index through length, replace that value with 0

    #returns the count of a given netmask in ones to know how much to index by    
    def countOnes(self, bnetmask):
        count = 0
        for i in bnetmask:
            if(i == 1):
                count +=1
                  
 

#this is another test to check
class Router:

    relations = {}
    sockets = {}
    ports = {}

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        # Storing entires 
        self.fowardTable = ForwardingTables()
        # Storing announcements  
        self.LoA = []
        # Storing the list of neighbor
        self.LoN = []
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.LoN.append(neighbor)
            print(self.LoN)
            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))
            

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    # Update MSG and foward announcement 
    def updateMSG(self, srcif, msg): 
        self.LoA = msg
        copypath = [self.asn]
        for i in msg["msg"]['ASPath']:
            copypath.append(i)   

        self.fowardTable.addToRouting(msg)

        if self.relations[srcif] == 'cust':
            for n in self.LoN: 
                if n != srcif:
                    msgCopy = {
                        "msg":  { #Copy msg 
                            "netmask" : msg["msg"]["netmask"],
                            "ASPath" :  copypath,
                            "network" : msg["msg"]["network"]
                        }, 
                        "src": n[:-1] + '1',
                        "dst": n,
                        "type": msg['type']
                    }
                     
                    self.send(n, json.dumps(msgCopy))   

    def dumpTableConfig(self, LoM): 
        LoT = []
        id = 0 
        for n in LoM: 
            src = n['src']
            format = {
                "origin" : n['msg']['origin'],
                "localpref" : n['msg']['localpref'], 
                "network" : n['msg']['network'],
                "ASPath" : n['msg']['ASPath'],
                "netmask" : n['msg']['netmask'],
                "peer" : src,
                "selfOrigin" : n['msg']['selfOrigin']
            }
            LoT.append(format)
        return LoT

    def dumpMsg(self, srcif, msg): 
        # generate dump message in correct format
        # Todo: Make aggregation in forwarding table
        LoM = self.fowardTable.entries
        table = self.dumpTableConfig(LoM) 
        jsonFormat = json.dumps(
            {
                "src" : srcif[:-1] + '1',        
                "dst" : srcif,   
                "type": "table",
                "msg" : table
            }
        )
        print(jsonFormat)
        self.send(srcif, jsonFormat )

    def determinebestpref(self, routes):
        if(len(routes) == 1):
            return routes

        returnlist = []
        currenthighest = routes[0][1]
        for entry in routes:
            if(entry[1] > currenthighest):
                returnlist.clear()
                returnlist.append(entry)
                currenthighest = entry[1]
            elif(entry[1] == currenthighest):
                returnlist.append(entry)

        return returnlist

    def determinebestorg(self, routes):
        if(len(routes) == 1):
            return routes

        returnlist = []
        for entry in routes:
            if(entry[2] == True):
                returnlist.append(entry)

        return returnlist



    def dataMsg(self, srcif, msg):
        msgdest = msg["dst"]
        ipfrom = ""

        matches = []

        #looks through the forwawrding table that I created with the prefixes with correct netmask
        #then looks through and determines which prefix best matches and then sends to it
        
        #looks through the forwarding table, the destination starts with the prefix of the network, network + netmask
        #afterwards, then it sends to the correct ip associated with it

        #multiple networks can share the ip
        
        #have to add in implementation for all those that work,
        for x in self.fowardTable.testrouting:
            if(msgdest.startswith(x)):
                matches.append(x)
                #ipfrom = self.fowardTable.testrouting[x][0]

        #checks how many networks are attached to this destination        
        if(len(matches) == 0):
            #this is where we would have a no route
            pass

        if(len(matches) == 2):
            #this is where we would have multiple entries for the destination network,
            #then we would need to find the longest path
            ipfrom = self.determinebestroute(matches)    

        if(len(matches) == 1):
            m = matches[0]
            print(self.fowardTable.testrouting[m])
            network1 = self.determinebestpref(self.fowardTable.testrouting[m])
            network = self.determinebestorg(network1)
            ipfrom = network[0][0]
            #these calls will be nested within each other
            #then since it is guarenteed that there will be no ties, this should find the best network,
            #there should then only be one item in the list, and then we always send to the ip which responds to the 0s index
            print(ipfrom)


                
        #print("what the entries look like " + str(testlist))        
        #print("the length of the matching networks with this string is " + str(len(testlist[0])))        
        
        self.send(ipfrom, json.dumps(msg))          

    # Processing the msg and delegate to delegation method
    def process_msgReceived(self, msg, srcif): 
        data = json.loads(msg); 

        if (data["type"] == 'update'): 
            self.updateMSG(srcif, data)
        
        if (data["type"] == 'data'): 
            self.dataMsg(srcif,data) 

        if (data["type"] == 'dump'):
            self.dumpMsg(srcif, data)

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)             
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                self.process_msgReceived(msg, srcif)
                print("Received message '%s' from %s" % (msg, srcif))
            
        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    # router = Router(7, {"7833-1.2.3.2-cust", "2374-192.168.0.2-peer" ,"1293-67.32.9.2-prov"})
    router.run()
