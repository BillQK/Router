#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, copy, re

#another test
class ForwardingTables: 
    def __init__(self):
        self.entries = [] 
        
    # Add entries 
    def add_entries(self, srcif, msg): 
        self.entries.append(msg)
        self.entries[len(self.entries)-1]['src'] = srcif

    def remove_entries(self, srcif, msg): 
        k = None
        for n in self.entries:
            for m in msg['msg']: 
                if n['src'] == srcif and n['network'] == m['network']:
                   k = n  
        
        self.entries.remove(k)
          
    
    def getOptimalIP(self, srcif, dest):
        destPrefix = dest[:dest.find(".")]
        
        LoN = {}

        for entry in self.entries: 
            prefNet = entry['network']
            prefNet = prefNet[:prefNet.find(".")]
            if destPrefix == prefNet: 
                LoN[entry['src']] = entry

        LoN = self.eliminatingIp(LoN, dest)

        if LoN:
            for k,v in LoN.items():
                return k       
        else: 
            return None

    def eliminatingIp(self, LoFNe, dest):
        LoN = {}
        LoN = self.testlongestPrefixMatch(LoFNe, dest)
        LoN = self.maxPref(LoN)
        LoN = self.selfOrigin(LoN)
        LoN = self.asPath(LoN)
        LoN = self.origin(LoN)
        LoN = self.smallestIp(LoN)

        return LoN

    def smallestIp(self, LofNe):
        LoN = {} 
        highest_Ip = "255.255.255.255"
        for k, v in LofNe.items(): 
           if self.smallerIp(k, highest_Ip): 
            highest_Ip = k 

        for k, v in LofNe.items():
            if k == highest_Ip:
                LoN[k] = v

        return LoN  
    
    def smallerIp(self, k, highest_Ip): 
        parsed_k = k.split(".")
        parsed_highest_Ip = highest_Ip.split(".")

        if (parsed_k < parsed_highest_Ip): 
            return True
        else: 
            return False

    def origin(self, LofNe): 
        LoN = {}
        best_origin = "UNK"

        for k, v in LofNe.items(): 
            if v['origin'] == "EGP": 
                best_origin = "EGP"
            elif v['origin'] == "IGP": 
                best_origin = "IGP"

        for k, v in LofNe.items():
            if v['origin'] == best_origin:
                LoN[k] = v
        return LoN

    def asPath(self,LofNe):
        LoN = {}
        largest_number = float("inf")
        for k, v in LofNe.items(): 
            if len(v['ASPath']) < largest_number:
                largest_number = len(v['ASPath'])
            
        for k ,v in LofNe.items():
            if len(v['ASPath']) == largest_number:
                LoN[k] = v

        return LoN

    def selfOrigin(self, LofNe):
        LoN = {}
        
        for k , v in LofNe.items():
            if v['selfOrigin']:
                LoN[k] = v
        
        if LoN:
            return LoN
        else: 
            return LofNe

    def maxPref(self, LofNe): 
        max_pref = float('-inf')
        LoN = {} 

        for k, v in LofNe.items():
            if v['localpref'] > max_pref:
                max_pref = v['localpref']
                
        for k, v in LofNe.items():
            if v['localpref'] == max_pref:
                LoN[k] = v

        return LoN

    def testlongestPrefixMatch(self, LoNs, dest):
        LoN = {}
        largestmatch = float('-inf')
        for k, v in LoNs.items():
            netprefix = self.convertbinary(v['network'], self.findnetmask(v['netmask']))
            if(dest.startswith(netprefix)):
                val = len(netprefix)
                if(val > largestmatch):
                    largestmatch = val

        for k, v in LoNs.items():
            netprefix = self.convertbinary(v['network'], self.findnetmask(v['netmask']))
            if(len(netprefix) == largestmatch):
                LoN[k] = v

        return LoN                     


    def findnetmask(self, netmask):
        count = 0
        nsplit = netmask.split('.')
        binary = []
        for i in nsplit:
            binary.append((bin(int(i)).replace('0b',"")).zfill(8))  

        num = "".join(binary)
        for i in num:
            if i == '1':
                count += 1

        return count


     #probably the most convoluted way to generate the prefix of a string...
    def convertbinary(self, network, netmask):
        #this is to split it up, and then calculate each deciman version of the binary string, 
        # then evetually fill it to be what we need
        nsplit = network.split('.')
        binary = []
        #creates the 8 bit representation of the network
        for i in nsplit:
            binary.append((bin(int(i)).replace('0b',"")).zfill(8))

        res = "".join(binary)
        resstring = ""
        #then we have a 32 bit number here, then we iterate through and take only the that can work
        #find some way to generate the number for the netmask
        for x in range(netmask):
            resstring += (res[x])
            #then this generates the specific prefix with the netmask
        str1 = resstring.zfill(32)
        #this then padds back the string into the 32 bit representation to be able to be grouped into the groups of 8
        #example
        N = 8
        sublist = [str1[n:n+ N] for n in range(0, len(str1), N)]
        list2 = []
        for i in sublist:
            val = int(i,2)
            if(val != 0):
                list2.append(str(val))

        prefix = ".".join(list2)        
        return prefix      
         

    # def longestPrefixMatch(self, LoNs, dest):  
    #     LoD = dest.split(".")
    #     LoN = {} 
    #     matchingCounter = float('-inf')

    #     for k, v in LofNe.items():
    #         columnsCounter = 0 
    #         LoNetmask = v['netmask'].split(".")
    #         LoNetwork = v['network'].split(".")
    #         m_bits = None
    #         d_bits = None
    #         n_bits = None
        
    #         for IPcolumns in range(4):
    #             n_bits = self.convertToBinary(LoNetwork[IPcolumns])
    #             m_bits = self.convertToBinary(LoNetmask[IPcolumns])
    #             d_bits = self.convertToBinary(LoD[IPcolumns])

    #         masked_N = ""
    #         while (len(masked_N) != 32):
    #             b_count = 0 
    #             if (n_bits[b_count] == "1" and m_bits[b_count] == "1"):
    #                 masked_N += "1"
    #                 b_count += 1
    #             else: 
    #                 masked_N += "0"
    #                 b_count += 1

    #         for a in range(len(masked_N)): 
    #             if masked_N[a] == d_bits[a]: 
    #                 columnsCounter += 1
    #             else: 
    #                 break
    #         if columnsCounter >= matchingCounter: 
    #             matchingCounter = columnsCounter
    #             LoN[k] = v
    
    #     return LoN


    def convertToBinary(self, ip):
        return format(int(ip), "b")

    #returns the count of a given netmask in ones to know how much to index by    
    def countConsecutiveOnes(self, bnetmask):
        count = 0
        for i in bnetmask:
            if(i == 1):
                count +=1
            else: 
                break 
        return count 
                  
 

#this is another test to check
class Router:

    relations = {}
    sockets = {}
    ports = {}

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        # Storing entires 
        self.fowardTable = ForwardingTables()
        # Storing announcements  
        self.LoA = []
        # Storing the list of neighbor
        self.LoN = []
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.LoN.append(neighbor)
            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))
            

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    # Update MSG and foward announcement 
    def updateMSG(self, srcif, msg): 
        self.LoA.append(msg)
        copypath = [self.asn]
        for i in msg["msg"]['ASPath']:
            copypath.append(i)   

        self.fowardTable.add_entries(srcif, msg['msg'])

        print("this is the relations array " + str(self.relations))
        print("this is what the list of neighbors array has " + str(self.LoN))

        if self.relations[srcif] == 'cust':
            for n in self.LoN: 
                if n != srcif:
                    msgCopy = {
                        "msg":  { #Copy msg 
                            "netmask" : msg["msg"]["netmask"],
                            "ASPath" :  copypath,
                            "network" : msg["msg"]["network"]
                        }, 
                        "src": n[:-1] + '1',
                        "dst": n,
                        "type": msg['type']
                    }
                     
                    self.send(n, json.dumps(msgCopy))

        #probably something kinda like this for peering            
        if self.relations[srcif] == 'peer' or self.relations[srcif] == 'prov':
            for n in self.LoN:
                if self.relations[n] == 'cust':

                    msgCopy = {
                        "msg":  {
                            "netmask" : msg["msg"]["netmask"],
                            "ASPath" :  copypath,
                            "network" : msg["msg"]["network"]
                        }, 
                        "src": n[:-1] + '1',
                        "dst": n,
                        "type": msg['type']
                    }
                    self.send(n, json.dumps(msgCopy))

    def dumpTableConfig(self, LoM): 
        LoT = []
        id = 0 
        for n in LoM: 
            src = n['src']
            format = {
                "origin" : n['origin'],
                "localpref" : n['localpref'], 
                "network" : n['network'],
                "ASPath" : n['ASPath'],
                "netmask" : n['netmask'],
                "peer" : src,
                "selfOrigin" : n['selfOrigin']
            }
            LoT.append(format)
        return LoT

    def dumpMsg(self, srcif, msg): 
        # generate dump message in correct format
        # Todo: Make aggregation in forwarding table
        LoM = self.fowardTable.entries
        table = self.dumpTableConfig(LoM) 
        jsonFormat = json.dumps(
            {
                "src" : srcif[:-1] + '1',        
                "dst" : srcif,   
                "type": "table",
                "msg" : table
            }
        )
        self.send(srcif, jsonFormat )

    def dataMsg(self, srcif, msg):
        #print("this is srcif " + str(srcif))
        #print("this is the message that should be printed " + str(msg))
        dest = msg['dst']

        ip_address = ForwardingTables.getOptimalIP(self.fowardTable, srcif, dest)
            # to check with the longest prefix if have multiple prefix matches -> 
            # to check with the localpref. if localpref -> 
            # to check with the selforigin. if all true -> 
            # to check with shortest ASPath. if equal cost -> 
            # to check with origin. Where IGP > EGP > UNK -> 
            # to check lowest ip
        #print("this is the ip address" + str(ip_address))   
        # msg as follows: -> ip of the router src
        # dst -> to the src of the message 
        noroutemsg = {"src": "need the ip from the router",
        "dst": srcif,
        "type": "no route",
        "msg": {}}

        print("this is what the ipaddress var is " + str(ip_address))
        if ip_address: 
            self.send(ip_address, json.dumps(msg))      
        else: 
            print("the no route message triggered")
            self.send(srcif, json.dump(""))

    def withDrawMsg(self,srcif, msg): 
        self.LoA.append(msg)
        self.fowardTable.remove_entries(srcif, msg)


    # Processing the msg and delegate to delegation method
    def process_msgReceived(self, msg, srcif): 
        data = json.loads(msg); 

        if (data["type"] == 'update'): 
            self.updateMSG(srcif, data)
        
        if (data["type"] == 'data'): 
            self.dataMsg(srcif,data) 

        if (data["type"] == 'dump'):
            self.dumpMsg(srcif, data)

        if (data["type"] == "withdraw"): 
            self.withDrawMsg(srcif, data)

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)             
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                self.process_msgReceived(msg, srcif)
            
        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
