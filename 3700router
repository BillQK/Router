#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, copy, re

#another test
class ForwardingTables: 
    def __init__(self):
        self.entries = [] 
        
    # Add entries 
    def add_entries(self, srcif, msg): 
        self.entries.append(msg)
        self.entries[len(self.entries)-1]['src'] = srcif

    def binaryconv(self, decimal):
        nsplit = decimal.split(".")
        binary = []
        for i in nsplit:
            binary.append((bin(int(i)).replace('0b',"")).zfill(8)) 

        num = "".join(binary)
        return num

    def groupip(self, bstr):
        N = 8
        sublist = [bstr[n:n+ N] for n in range(0, len(bstr), N)]
        list2 = []
        for i in sublist:
            val = int(i,2)
            list2.append(str(val))

        value = ".".join(list2)
        return value

    def bprefix(self, network, netmask):
        num = self.binaryconv(network)
        mask = self.findnetmask(netmask)
        retstr = ""
        if(mask == 0):
            return "0"
        for elem in range(mask):
            retstr += (num[elem])

        return retstr

    def checkattributes(self, elem1, elem2):
        if elem1['localpref'] == elem2['localpref']:
            if elem1['ASPath'] == elem2['ASPath']:
                if elem1['origin'] == elem2['origin']:
                    if elem1['selfOrigin'] == elem2['selfOrigin']:
                        return True

    def determineadj(self, elem1, elem2):
        binaryelem1 = self.bprefix(elem1['network'], elem1['netmask'])
        binaryelem2 = self.bprefix(elem2['network'], elem2['netmask'])
        test = bin(int(binaryelem1, 2) + 1).replace('0b',"")
        if(test == binaryelem2):
            return True

    def decrementbits(self, netmask):
        num = self.binaryconv(netmask)
        str2 = list(num)
        netmaskcount = self.findnetmask(netmask)
        str2[netmaskcount -1] = "0"
        str2 = "".join(str2)
        netmask = self.groupip(str2)

        return netmask                 

    def aggregation(self):
        for k in self.entries:
            for v in self.entries:
                if(self.determineadj(k,v)):
                    if(k['src'] == v['src']):
                        if(self.checkattributes(k, v)):
                            self.entries.remove(v)
                            #its definetly has to deal with this, but why does it even get here???
                            #like mutating the acutal varible, not a copy of the variable, so the changes that I make here
                            #it reflects down to the other messages
                            k['netmask'] = self.decrementbits(k['netmask'])

    #when                         


    def remove_entries(self, srcif, msg, LoA): 
        k = None
        for n in self.entries:
            for m in msg['msg']: 
                if n['src'] == srcif and n['network'] == m['network'] and n['netmask'] == m['netmask']:
                   print("our entries source " + str(n['src']))
                   print("our entries network " + str(m['network']))
                   print("our entries netmask " + str(n['netmask'])) 
                   k = n

        if(k == None):
            print("this method got called")
            self.reconstructtable(LoA)
        else:
            print("mistakenly removed from wrong list")
            self.entries.remove(k)

    def reconstructtable(self, LoA):
        self.entries.clear()
        print("items in entries list after cleared" + str(self.entries))
        withdrawnelems = []
        for n in LoA:
            if(n["type"] == 'withdraw'):
                LoM = n['msg']
                for m in LoM:
                    withdrawnelems.append(m)

        
        print("withdrawn messages" + str(withdrawnelems))

        for k in LoA:
            if(k['type'] == 'update'):                        
                #print("current message:" + str(k))
                entry = {"network": k['msg']['network'], "netmask" : k['msg']['netmask']}
                #print("withdraw table" +str(withdrawnelems))
                #print("current entry" + str(entry))
                if(entry in withdrawnelems):
                    pass
                else:
                   self.add_entries(k['src'], k['msg'])
                   self.aggregation()
                   print("current table:" + str(self.entries)) 


        #print("hopefully this works " + str(self.entries))           
 
    
    def getOptimalIP(self, srcif, dest):
        destPrefix = dest[:dest.find(".")]
        
        LoN = {}

        for entry in self.entries:
            prefNet = entry['network']
            prefNet = prefNet[:prefNet.find(".")]
            if destPrefix == prefNet: 
                LoN[entry['src']] = entry

        LoN = self.eliminatingIp(LoN, dest)

        if LoN:
            
            for k,v in LoN.items():
                if k is None:
                    print(srcif + "this is a bad route")
                return k       
        else: 
            return None

    def eliminatingIp(self, LoFNe, dest):
        LoN = {}
        LoN = self.longestPrefixMatch(LoFNe, dest)
        print("this is after longest matching prefix" + str(LoN))
        LoN = self.maxPref(LoN)
        LoN = self.selfOrigin(LoN)
        LoN = self.asPath(LoN)
        LoN = self.origin(LoN)
        LoN = self.smallestIp(LoN)

        return LoN

    def smallestIp(self, LofNe):
        LoN = {} 
        highest_Ip = "255.255.255.255"
        for k, v in LofNe.items(): 
           if self.smallerIp(k, highest_Ip): 
            highest_Ip = k 

        for k, v in LofNe.items():
            if k == highest_Ip:
                LoN[k] = v

        return LoN  
    
    def smallerIp(self, k, highest_Ip): 
        parsed_k = k.split(".")
        parsed_highest_Ip = highest_Ip.split(".")

        if (parsed_k < parsed_highest_Ip): 
            return True
        else: 
            return False

    def origin(self, LofNe): 
        LoN = {}
        best_origin = "UNK"

        for k, v in LofNe.items(): 
            if v['origin'] == "EGP": 
                best_origin = "EGP"
            elif v['origin'] == "IGP": 
                best_origin = "IGP"

        for k, v in LofNe.items():
            if v['origin'] == best_origin:
                LoN[k] = v
        return LoN

    def asPath(self,LofNe):
        LoN = {}
        largest_number = float("inf")
        for k, v in LofNe.items(): 
            if len(v['ASPath']) < largest_number:
                largest_number = len(v['ASPath'])
            
        for k ,v in LofNe.items():
            if len(v['ASPath']) == largest_number:
                LoN[k] = v

        return LoN

    def selfOrigin(self, LofNe):
        LoN = {}
        
        for k , v in LofNe.items():
            if v['selfOrigin']:
                LoN[k] = v
        
        if LoN:
            return LoN
        else: 
            return LofNe

    def maxPref(self, LofNe): 
        max_pref = float('-inf')
        LoN = {} 

        for k, v in LofNe.items():
            if v['localpref'] > max_pref:
                max_pref = v['localpref']
                
        for k, v in LofNe.items():
            if v['localpref'] == max_pref:
                LoN[k] = v

        return LoN

    def longestPrefixMatch(self, LoNs, dest):
        LoN = {}
        largestmatch = float('-inf')
        for k, v in LoNs.items():
            netprefix = self.convertbinary(v['network'], self.findnetmask(v['netmask']))
            desbin = self.binaryconv(dest)
            print(LoN.items())
            print(v['network'])
            print(v['netmask'])
            print(netprefix)

            print(dest)
            print(desbin)
            if(desbin.startswith(netprefix)):
                val = len(netprefix)
                if(val > largestmatch):
                    largestmatch = val

        for k, v in LoNs.items():
            netprefix = self.convertbinary(v['network'], self.findnetmask(v['netmask']))
            if(len(netprefix) == largestmatch):
                LoN[k] = v

        return LoN                     


    def findnetmask(self, netmask):
        count = 0
        nsplit = netmask.split('.')
        binary = []
        for i in nsplit:
            binary.append((bin(int(i)).replace('0b',"")).zfill(8))  

        num = "".join(binary)
        for i in num:
            if i == '1':
                count += 1

        return count


     #probably the most convoluted way to generate the prefix of a string...
    def convertbinary(self, network, netmask):
        #this is to split it up, and then calculate each deciman version of the binary string, 
        # then evetually fill it to be what we need
        nsplit = network.split('.')
        binary = []
        #creates the 8 bit representation of the network
        for i in nsplit:
            binary.append((bin(int(i)).replace('0b',"")).zfill(8))

        res = "".join(binary)
        resstring = ""
        #then we have a 32 bit number here, then we iterate through and take only the that can work
        #find some way to generate the number for the netmask
        for x in range(netmask):
            resstring += (res[x])
     
        return resstring    
         
class Router:

    relations = {}
    sockets = {}
    ports = {}

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        # Storing entires 
        self.fowardTable = ForwardingTables()
        # Storing announcements  
        self.LoA = []
        # Storing the list of neighbor
        self.LoN = []
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.LoN.append(neighbor)
            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))
            

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    # Update MSG and foward announcement 
    def updateMSG(self, srcif, msg):
        msgcopy = {"src" : msg['src'],
                    "dst" : msg["dst"],
                    "type" : "update",
                    "msg" : 
                    {
                        'network': msg['msg']['network'],
                        'netmask': msg['msg']['netmask'],
                        'localpref': msg['msg']['localpref'],
                        'selfOrigin': msg['msg']['selfOrigin'],
                        'ASPath': msg['msg']['ASPath'],
                        'origin': msg['msg']['origin'],
                    }
                    }

        self.LoA.append(msgcopy)
        print("current annoucement cache" + str(self.LoA))
        copypath = [self.asn]
        for i in msg["msg"]['ASPath']:
            copypath.append(i)   

        self.fowardTable.add_entries(srcif, msg['msg'])
        self.fowardTable.aggregation() 

        if self.relations[srcif] == 'cust':
            for n in self.LoN: 
                if n != srcif:
                    msgCopy = {
                        "msg":  { #Copy msg 
                            "netmask" : msg["msg"]["netmask"],
                            "ASPath" :  copypath,
                            "network" : msg["msg"]["network"]
                        }, 
                        "src": n[:-1] + '1',
                        "dst": n,
                        "type": msg['type']
                    }
                     
                    self.send(n, json.dumps(msgCopy))

        #probably something kinda like this for peering            
        elif self.relations[srcif] == 'peer' or self.relations[srcif] == 'prov':
            for n in self.LoN:
                if self.relations[n] == 'cust':
                    msgCopy = {
                        "msg":  {
                            "netmask" : msg["msg"]["netmask"],
                            "ASPath" :  copypath,
                            "network" : msg["msg"]["network"]
                        }, 
                        "src": n[:-1] + '1',
                        "dst": n,
                        "type": msg['type']
                    }
                    self.send(n, json.dumps(msgCopy))

    def dumpTableConfig(self, LoM): 
        LoT = []
        id = 0 
        for n in LoM: 
            src = n['src']
            format = {
                "origin" : n['origin'],
                "localpref" : n['localpref'], 
                "network" : n['network'],
                "ASPath" : n['ASPath'],
                "netmask" : n['netmask'],
                "peer" : src,
                "selfOrigin" : n['selfOrigin']
            }
            LoT.append(format)
        return LoT

    def dumpMsg(self, srcif, msg): 
        LoM = self.fowardTable.entries
        table = self.dumpTableConfig(LoM) 
        jsonFormat = json.dumps(
            {
                "src" : srcif[:-1] + '1',        
                "dst" : srcif,   
                "type": "table",
                "msg" : table
            }
        )
        self.send(srcif, jsonFormat)

    def dataMsg(self, srcif, msg):
        dest = msg['dst']
        
        ip_address = ForwardingTables.getOptimalIP(self.fowardTable, srcif, dest)

        #print("this is the ip address we found " + str(ip_address))
    
        noroutemsg = {
                    "src": srcif[:-1] + "1",
                    "dst": srcif,
                    "type": "no route",
                    "msg": {}
                    }

        if ip_address: 
            relsrc = self.relations[srcif]
            reldst = self.relations[ip_address]
            if  relsrc == 'cust' or reldst == "cust" :
                self.send(ip_address, json.dumps(msg))   
            else: 
                self.send(srcif, json.dumps(noroutemsg))   
        else: 
            self.send(srcif, json.dumps(noroutemsg))

    def withDrawMsg(self,srcif, msg): 
        self.LoA.append(msg)
        self.fowardTable.remove_entries(srcif, msg, self.LoA)
        LoNM = []

        for i in range(len(msg['msg'])): 
            ListofMsg = msg['msg']
            newJson = {
                'netmask' : ListofMsg[i]['netmask'],
                'network' : ListofMsg[i]['network']
            }
            LoNM.append(newJson)

        for n in self.LoN: 
            if n != srcif:
                msgCopy = {
                    "msg": LoNM, 
                    "src": n[:-1] + '1',
                    "dst": n,
                    "type": msg['type']
                }
                    
                self.send(n, json.dumps(msgCopy))
            

    # Processing the msg and delegate to delegation method
    def process_msgReceived(self, msg, srcif): 
        data = json.loads(msg) 

        if (data["type"] == 'update'):
            print("before we parsed into update message list:" + str(data)) 
            self.updateMSG(srcif, data)
        
        if (data["type"] == 'data'): 
            self.dataMsg(srcif,data) 

        if (data["type"] == 'dump'):
            self.dumpMsg(srcif, data)

        if (data["type"] == "withdraw"): 
            self.withDrawMsg(srcif, data)


    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)             
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                self.process_msgReceived(msg, srcif)
            
        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
