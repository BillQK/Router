#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, copy, re

#another test
class ForwardingTables: 
    def __init__(self):
        self.entries = []
        self.testrouting = {}

    # Add entries 
    def add_entries(self, srcif, msg): 
        self.entries.append(msg)

    def printData(self):
        for e in self.entries.values(): 
            print(e)

    def addToRouting(self, msg):
        routeinfo = []
        peer = msg["src"]
        #have a port field in there as well

        network = msg["msg"]["network"]
        netmask = msg['msg']['netmask']

        prefixednetwork = self.determinenetwork(network, netmask)
        self.testrouting.setdefault(prefixednetwork, [])
        self.testrouting[prefixednetwork].append(peer)

       #subnet mask/bitwise operations, and get the network ip 
    def determinenetwork(self, network, netmask):
        test = []
        pattern = re.compile(r'255')
        matches = pattern.findall(netmask)
        network = network.split(".")

        for i in range(len(matches)):
            test.append(network[i])

        test = '.'.join(test)

        return test


    def convertToBinary(self, msg):
        prefix = msg["network"]
        netmask = msg["netmask"]
        
        #converting to eventually check withe netmask(count the ones)
        #with the number that has the correct amount depending on the netmask
        #then thats the address that we send things to?

        separatedecimal = prefix.split(".")
        print(separatedecimal)
        nlist = []
        testlist = []

        for i in separatedecimal:
            nlist.append(bin(int(i)).replace("0b", ""))

        for i in nlist:
            testlist.append(i.zfill(8))

        str = '.'.join(testlist)
        num = self.countOnes(str)  

        print(str)    
        #index = countOnes(bnetmask)
        #for index through length, replace that value with 0

    #returns the count of a given netmask in ones to know how much to index by    
    def countOnes(self, bnetmask):
        count = 0
        for i in bnetmask:
            if(i == 1):
                count +=1
                  
 

#this is another test to check
class Router:

    relations = {}
    sockets = {}
    ports = {}

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        # Storing entires 
        self.fowardTable = ForwardingTables()
        # Storing announcements  
        self.LoA = []
        # Storing the list of neighbor
        self.LoN = []
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.LoN.append(neighbor)
            print(self.LoN)
            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))
            

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    # Update MSG and foward announcement 
    def updateMSG(self, srcif, msg): 
        self.LoA = msg
        copypath = [self.asn]
        for i in msg["msg"]['ASPath']:
            copypath.append(i)   

        self.fowardTable.addToRouting(msg)

        if self.relations[srcif] == 'cust':
            for n in self.LoN: 
                if n != srcif:
                    msgCopy = {
                        "msg":  { #Copy msg 
                            "netmask" : msg["msg"]["netmask"],
                            "ASPath" :  copypath,
                            "network" : msg["msg"]["network"]
                        }, 
                        "src": n[:-1] + '1',
                        "dst": n,
                        "type": msg['type']
                    }
                     
                    self.send(n, json.dumps(msgCopy))   

    def dumpTableConfig(self, LoM): 
        LoT = []
        id = 0 
        for n in LoM: 
            src = n['src']
            format = {
                "origin" : n['msg']['origin'],
                "localpref" : n['msg']['localpref'], 
                "network" : n['msg']['network'],
                "ASPath" : n['msg']['ASPath'],
                "netmask" : n['msg']['netmask'],
                "peer" : src,
                "selfOrigin" : n['msg']['selfOrigin']
            }
            LoT.append(format)
        return LoT

    def dumpMsg(self, srcif, msg): 
        # generate dump message in correct format
        # Todo: Make aggregation in forwarding table
        LoM = self.fowardTable.entries
        table = self.dumpTableConfig(LoM) 
        jsonFormat = json.dumps(
            {
                "src" : srcif[:-1] + '1',        
                "dst" : srcif,   
                "type": "table",
                "msg" : table
            }
        )
        print(jsonFormat)
        self.send(srcif, jsonFormat )

    def dataMsg(self, srcif, msg):
        msgdest = msg["dst"]
        ipfrom = ""

        testlist = []

        #looks through the forwawrding table that I created with the prefixes with correct netmask
        #then looks through and determines which prefix best matches and then sends to it
        for x in self.fowardTable.testrouting:
            if(msgdest.startswith(x)):
                testlist.append(self.fowardTable.testrouting[x])
                ipfrom = self.fowardTable.testrouting[x][0]

                
        print("entries currently that match " + str(testlist))        
        print("the length of the matching networks with this string is " + str(len(testlist[0])))        
        
        self.send(ipfrom, json.dumps(msg))          

    # Processing the msg and delegate to delegation method
    def process_msgReceived(self, msg, srcif): 
        data = json.loads(msg); 

        if (data["type"] == 'update'): 
            self.updateMSG(srcif, data)
        
        if (data["type"] == 'data'): 
            self.dataMsg(srcif,data) 

        if (data["type"] == 'dump'):
            self.dumpMsg(srcif, data)

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)             
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                self.process_msgReceived(msg, srcif)
                print("Received message '%s' from %s" % (msg, srcif))
            
        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    # router = Router(7, {"7833-1.2.3.2-cust", "2374-192.168.0.2-peer" ,"1293-67.32.9.2-prov"})
    router.run()
