#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, copy, re

#another test
class ForwardingTables: 
    def __init__(self):
        self.entries = []
        
    # Add entries 
    def add_entries(self, srcif, msg): 
        self.entries.append(msg);
        self.entries[len(self.entries)-1]['src'] = srcif 

    def getOptimalIP(self, srcif, dest): 
        destPrefix = dest[:dest.find(".")]
        
        LoN = {}

        for entry in self.entries: 
            prefNet = entry['network']
            prefNet = prefNet[:prefNet.find(".")]
            if destPrefix == prefNet: 
                LoN[entry['src']] = entry

        LoN = self.longestPrefixMatch(LoN, dest)
        LoN = self.maxPref(LoN)
        LoN = self.selfOrigin(LoN)
        LoN = self.asPath(LoN)
        LoN = self.origin(LoN)


        
        if LoN:
            for k,v in LoN.items(): 
                return k
        else: 
            return None


    def origin(self, LoNs): 
        LoN = {}
        best_origin = "UNK"
        for k, v in LoNs.items(): 
            pass
        return LoNs

    def asPath(self,LoNs):
        LoN = {}
        largest_number = float("inf")
        for k, v in LoNs.items(): 
            if len(v['ASPath']) < largest_number:
                largest_number = len(v['ASPath'])
            
        for k ,v in LoNs.items():
            if len(v['ASPath']) == largest_number:
                LoN[k] = v

        return LoN

    def selfOrigin(self, LoNs):
        LoN = {}
        
        for k , v in LoNs.items():
            if v['selfOrigin']:
                LoN[k] = v
        
        if LoN:
            return LoN
        else: 
            return LoNs

    def maxPref(self, LoNs): 
        max_pref = float('-inf')
        routes = {} 

        for k, v in LoNs.items():
            if v['localpref'] > max_pref:
                max_pref = v['localpref']
        
        for k, v in LoNs.items():
            if v['localpref'] == max_pref:
                routes[k] = v

        return routes

    def longestPrefixMatch(self, LoNs, dest): 
        LoD = dest.split(".")
        LoN = {} 
        matchingCounter = float('-inf')

        for k, v in LoNs.items():
            columnsCounter = 0 
            LoNetmask = v['netmask'].split(".")
            m_bits = None
            d_bits = None
        
            for IPcolumns in range(4): 
                m_bits = self.convertToBinary(LoNetmask[IPcolumns])
                d_bits = self.convertToBinary(LoD[IPcolumns])

            masked_N = ""
            consecutiveOnes = self.countConsecutiveOnes(m_bits)
            while (len(masked_N) != 32):
                b_count = 0 
                if (consecutiveOnes != b_count):
                    masked_N += "1"
                    b_count += 1
                else: 
                    masked_N += "0"

            for a in range(len(masked_N)): 
                if masked_N[a] == d_bits[a]: 
                    columnsCounter += 1
                else: 
                    break
            if columnsCounter >= matchingCounter: 
                matchingCounter = columnsCounter
                LoN[k] = v
    
        return LoN


    def convertToBinary(self, ip):
        return format(int(ip), "b")

    #returns the count of a given netmask in ones to know how much to index by    
    def countConsecutiveOnes(self, bnetmask):
        count = 0
        for i in bnetmask:
            if(i == 1):
                count +=1
            else: 
                break 
        return count 
                  
 

#this is another test to check
class Router:

    relations = {}
    sockets = {}
    ports = {}

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        # Storing entires 
        self.fowardTable = ForwardingTables()
        # Storing announcements  
        self.LoA = []
        # Storing the list of neighbor
        self.LoN = []
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.LoN.append(neighbor)
            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))
            

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    # Update MSG and foward announcement 
    def updateMSG(self, srcif, msg): 
        self.LoA = msg
        copypath = [self.asn]
        for i in msg["msg"]['ASPath']:
            copypath.append(i)   

        self.fowardTable.add_entries(srcif, msg['msg'])

        if self.relations[srcif] == 'cust':
            for n in self.LoN: 
                if n != srcif:
                    msgCopy = {
                        "msg":  { #Copy msg 
                            "netmask" : msg["msg"]["netmask"],
                            "ASPath" :  copypath,
                            "network" : msg["msg"]["network"]
                        }, 
                        "src": n[:-1] + '1',
                        "dst": n,
                        "type": msg['type']
                    }
                     
                    self.send(n, json.dumps(msgCopy))   

    def dumpTableConfig(self, LoM): 
        LoT = []
        id = 0 
        for n in reversed(LoM): 
            src = n['src']
            format = {
                "origin" : n['origin'],
                "localpref" : n['localpref'], 
                "network" : n['network'],
                "ASPath" : n['ASPath'],
                "netmask" : n['netmask'],
                "peer" : src,
                "selfOrigin" : n['selfOrigin']
            }
            LoT.append(format)
        return LoT

    def dumpMsg(self, srcif, msg): 
        # generate dump message in correct format
        # Todo: Make aggregation in forwarding table
        LoM = self.fowardTable.entries
        table = self.dumpTableConfig(LoM) 
        jsonFormat = json.dumps(
            {
                "src" : srcif[:-1] + '1',        
                "dst" : srcif,   
                "type": "table",
                "msg" : table
            }
        )
        print(jsonFormat)
        self.send(srcif, jsonFormat )

    def dataMsg(self, srcif, msg):
        dest = msg['dst']

        ip_address = ForwardingTables.getOptimalIP(self.fowardTable, srcif, dest)
            # to check with the longest prefix if have multiple prefix matches -> 
            # to check with the localpref. if localpref -> 
            # to check with the selforigin. if all true -> 
            # to check with shortest ASPath. if equal cost -> 
            # to check with origin. Where IGP > EGP > UNK -> 
            # to check lowest ip 

        self.send(ip_address, json.dumps(msg))      

    # Processing the msg and delegate to delegation method
    def process_msgReceived(self, msg, srcif): 
        data = json.loads(msg); 

        if (data["type"] == 'update'): 
            self.updateMSG(srcif, data)
        
        if (data["type"] == 'data'): 
            self.dataMsg(srcif,data) 

        if (data["type"] == 'dump'):
            self.dumpMsg(srcif, data)

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)             
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                self.process_msgReceived(msg, srcif)
                print("Received message '%s' from %s" % (msg, srcif))
            
        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
